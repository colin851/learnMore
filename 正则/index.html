<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no" />
		<link rel="stylesheet" href="../css/reset.css" />
		<title></title>
		<style>
		body{
			text-align: center;
		}
			.container{
				padding:10px;
				
			}
			table{
				margin: 0 auto;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<p>创建正则表达式和创建字符串类似，创建正则表达式提供了两种方法，一种是采用new运算符，另一个是采用字面量方式。</p>
			<span>1.</span>
			<pre>var box = new RegExp('box');  //第一个参数是模式字符串 </pre>
			<pre>alert(box);  // /box/两个反斜杠是正则表达式的字面量表示法 </pre>
			<pre>var box</pre>
		</div>
		
		<br />
		<br />
		<h1>字符类：单个字符和数字</h1>
		<table border="" cellspacing="" cellpadding="">
			<th>元字符/元符号</th>
			<th>匹配情况</th>
			<tr>
				<td>.</td>
				<td>匹配除换行符外的任意字符</td>
			</tr>
			<tr>
				<td>[^a-z0-9]</td>
				<td>匹配任意不在括号中的字符集中的字符</td>
			</tr>
			<tr>
				<td>\d</td>
				<td>匹配数字</td>
			</tr>
			<tr>
				<td>\D	</td>
				<td>匹配非数字，同[^0-9]相同</td>
			</tr>
			<tr>
				<td>\w</td>
				<td>匹配字母和数字及_</td>
			</tr>
			<tr>
				<td>\W	</td>
				<td>匹配非字母和数字及_</td>
			</tr>
		</table>
		
		<br />
		<br />
		<h1>字符类：空白字符</h1>
		<table border="" cellspacing="" cellpadding="">
			<th>元字符/元符号</th>
			<th>匹配情况</th>
			<tr>
				<td>\0</td>
				<td>匹配null字符</td>
			</tr>
			<tr>
				<td>\b</td>
				<td>匹配空格字符</td>
			</tr>
			<tr>
				<td>\f</td>
				<td>匹配进纸字符</td>
			</tr>
			<tr>
				<td>\n	</td>
				<td>匹配换行符</td>
			</tr>
			<tr>
				<td>\r</td>
				<td>匹配回车字符</td>
			</tr>
			<tr>
				<td>\t	</td>
				<td>匹配制表符</td>
			</tr>
			<tr>
				<td>\s	</td>
				<td>匹配空白字符、空格、制表符和换行符</td>
			</tr>
			<tr>
				<td>\S	</td>
				<td>匹配非空白字符</td>
			</tr>
		</table>
	<br />
		<br />
	<h1>字符类：空白字符</h1>
		<table border="" cellspacing="" cellpadding="">
			<th>元字符/元符号</th>
			<th>匹配情况</th>
			<tr>
				<td>\0</td>
				<td>匹配null字符</td>
			</tr>
			<tr>
				<td>\b</td>
				<td>匹配空格字符</td>
			</tr>
			<tr>
				<td>\f</td>
				<td>匹配进纸字符</td>
			</tr>
			<tr>
				<td>\n	</td>
				<td>匹配换行符</td>
			</tr>
			<tr>
				<td>\r</td>
				<td>匹配回车字符</td>
			</tr>
			<tr>
				<td>\t	</td>
				<td>匹配制表符</td>
			</tr>
			<tr>
				<td>\s	</td>
				<td>匹配空白字符、空格、制表符和换行符</td>
			</tr>
			<tr>
				<td>\S	</td>
				<td>匹配非空白字符</td>
			</tr>
		</table>
	
	<br />
		<br />
	<h1>字符类：锚字符</h1>
		<table border="" cellspacing="" cellpadding="">
			<th>元字符/元符号</th>
			<th>匹配情况</th>
			<tr>
				<td>^</td>
				<td>行首匹配</td>
			</tr>
			<tr>
				<td>$</td>
				<td>行尾匹配</td>
			</tr>
			<tr>
				<td>\A</td>
				<td>只有匹配字符串开始处</td>
			</tr>
			<tr>
				<td>\b	</td>
				<td>匹配单词边界，词在[]内时无效</td>
			</tr>
			<tr>
				<td>\B</td>
				<td>匹配非单词边界</td>
			</tr>
			<tr>
				<td>\G	</td>
				<td>匹配当前搜索的开始位置</td>
			</tr>
			<tr>
				<td>\Z	</td>
				<td>匹配字符串结束处或行尾</td>
			</tr>
			<tr>
				<td>\z	</td>
				<td>只匹配字符串结束处</td>
			</tr>
		</table>
	
	<br />
		<br />
	<h1>字符类：重复字符</h1>
		<table border="" cellspacing="" cellpadding="">
			<th>元字符/元符号</th>
			<th>匹配情况</th>
			<tr>
				<td>x?</td>
				<td>匹配0个或1个x</td>
			</tr>
			<tr>
				<td>x*</td>
				<td>匹配0个或任意多个x</td>
			</tr>
			<tr>
				<td>x+</td>
				<td>匹配至少一个x</td>
			</tr>
			<tr>
				<td>(xyz)+	</td>
				<td>匹配至少一个(xyz)</td>
			</tr>
			<tr>
				<td>x{m,n}</td>
				<td>匹配最少m个、最多n个x</td>
			</tr>
		</table>
		
			<br />
		<br />
	<h1>字符类：替代字符</h1>
		<table border="" cellspacing="" cellpadding="">
			<th>元字符/元符号</th>
			<th>匹配情况</th>
			<tr>
				<td>this|where|logo</td>
				<td>匹配this或where或logo中任意一个</td>
			</tr>
		</table>

	<br />
		<br />
	<h1>字符类：记录字符</h1>
		<table border="" cellspacing="" cellpadding="">
			<th>元字符/元符号</th>
			<th>匹配情况</th>
			<tr>
				<td>(string)</td>
				<td>用于反向引用的分组</td>
			</tr>
			<tr>
				<td>\1或$1</td>
				<td>匹配第一个分组中的内容</td>
			</tr>
			<tr>
				<td>\2或$2</td>
				<td>匹配第二个分组中的内容</td>
			</tr>
			<tr>
				<td>\3或$3	</td>
				<td>匹配第三个分组中的内容</td>
			</tr>
		</table>

	

	
	
	
	<script>
	//一、创建正则表达式
	//第一种
	//	var box = new RegExp('box');
	//	alert(box)
		var box = new RegExp('box','ig'); //第二个参数可选，模式修饰符
		//i，忽略大小写；g全局匹配；m多行匹配
	//第二种	
		var box = /box/ig;  //使用字面量的正则
		
/*---------------------------------------分割线------------------------------------------------*/			
	//二、测试正则表达式	
	//RegExp对象包含两个方法：test()和exec()，功能基本相似，用于测试字符串匹配。
	//test()方法在字符串中查找是否存在指定的正则表达式并返回布尔值，如果存在则返回true，不存在则返回false。
	//exec()方法也用于在字符串中查找指定正则表达式，如果exec()方法执行成功，则返回包含该查找字符串的相关信息数组。如果执行失败，则返回null。
	
	/*使用new运算符的test方法示例*/
	var pattern = new RegExp('Box');  //模式
	var str = 'box';
	//alert(pattern.test(str));		//false 大小写不一致
	
	/*使用字面量方式的test方法示例*/
	var pattern = /box/i;							//创建正则模式，不区分大小写
	var str = 'This is a Box!';
	//alert(pattern.test(str));
	
	//alert(/box/i.test('This is a Box!'));	//true
	
	/*使用exec返回匹配数组*/
	var pattern = /box/i;
	var str = 'This is Box';
	//alert(pattern.exec(str)) //匹配了返回数组，否则返回null；
/*---------------------------------------分割线------------------------------------------------*/
	//三、使用字符串的正则表达式方法
	//除了test()和exec()方法，String对象也提供了4个使用正则表达式的方法。
	
	/*使用match方法获取获取匹配数组*/
	var pattern = /Box/ig;
	var str = 'This is a Box! That is a Box!';
	var a = str.match(pattern);
	//alert(a)  //返回数组

	/*使用search来查找匹配数据*/
	var pattern = /box/ig;
	var str = 'This is a Box!，That is a Box too';
	//alert(str.search(pattern));	//查找到返回位置，否则返回-1
	//PS：因为search方法查找到即返回，也就是说无需g全局
	
	/*使用replace替换匹配到的数据*/
	var pattern = /box/ig;
	var str = 'This is a Box!，That is a Box too';
	//alert(str.replace(pattern,'Tom'))
	
	/*使用split拆分成字符串数组*/
	var pattern = / /ig;
	var str = 'This is a Box!，That is a Box too';
	//alert(str.split(pattern));						//将空格拆开分组成数组
	
	
	/*---------------------------------------分割线------------------------------------------------*/
	//四．获取控制
	
	
	/*使用点元字符*/
	var pattern = /g..gle/;						// .匹配一个任意字符
	var str = 'google';
	var str = 'g12gle';
	//alert(pattern.test(str));
	
	/*重复匹配*/
	var pattern = /go*gle/;			// o*，表示0个，一个，或者多个o；
	var str = 'goooooogle';
	var str1 = 'gbbbgle'; //false
	//alert(pattern.test(str));

	var pattern = /go+gle/;			// o+，表示至少匹配一个o；
	var str = 'ggle';
	//alert(pattern.test(str));
	
	var pattern = /go?gle/;			// o?，表示匹配0个或1个o；
	var str = 'google';
	//alert(pattern.test(str));
	
	var pattern = /g.?gle/;			// .?，表示匹配0个或1个任意字符；
	var str = 'g2gle';
	//alert(pattern.test(str));
	
	var pattern = /go{2,4}gle/;			// o{2,4}，表示匹配2个到4个o，包括2和4；
	var str = 'gooooogle';
	//alert(pattern.test(str));
	
	var pattern = /go{3}gle/;			// o{3}，表示匹配只限定3个o；
	var str = 'gooogle';
	//alert(pattern.test(str));
	
	var pattern = /go{3,}gle/;			// {3,}，表示匹配3个或3个以上o；
	var str = 'google';
	//alert(pattern.test(str));


	/*使用字符类匹配*/
	var pattern = /[a-z]oogle/;				//[a-z]表示任意一个a-z中小写的字符
	var str = 'boogle';
	//alert(pattern.test(str));
	
	var pattern = /[a-zA-Z0-9]oogle/;		//[a-zA-Z0-9]表示任意一个a-zA-Z0-9中的字符
	var str = 'boogle';
	//alert(pattern.test(str));
	
	var pattern = /[^a-z]oogle/;				//[a-z]表示任意一个非a-z中的字符
	var str = '2oogle';
	//alert(pattern.test(str));
	
	var pattern = /\woogle/;				//\w表示[a-zA-z_];\W表示[^a-zA-z_];
	var str = '-oogle';
	//alert(pattern.test(str));
	
	var pattern = /\doogle/;				//\d表示[0-9];\D表示[^0-9];
	var str = '-oogle';
	//alert(pattern.test(str));
	
	
	/*使用锚元字符匹配*/
	var pattern = /^[a-z]oogle/;				//从行首开始匹配
	var str = 'aaoogle';
	//alert(pattern.test(str));
	
	var pattern = /^[a-z]oogle$/;				//^强制行首匹配 $强制行尾匹配
	var str = 'aoogle  sdasd';
	//alert(pattern.test(str));
	
	var pattern = /goo gle/;						//直接使用空格匹配		
	var str = 'goo gle';
	//alert(pattern.test(str));
	
	var pattern = /goo\sgle/;						//\s可以匹配空白字符、空格、制表符和换行符		
	var str = 'goo sgle';
	//alert(pattern.test(str));
	
	var pattern = /google\b/;						//\b可以匹配是否到了边界	
	var str = 'google';
	//alert(pattern.test(str));
	
	/*使用或模式匹配*/
	var pattern = /google|baidu|bing/;				//匹配三种其中一种字符串
	var str = 'This is google'; 					//匹配模式不是相等
	//alert(pattern.test(str));
	
	/*使用分组模式匹配*/
	var pattern = /(google){4,8}/;					//匹配分组里的字符串4-8次，匹配google4到8次	
	var str = 'googlegoogle';
	//alert(pattern.test(str));
	
	var pattern = /8(.*)8/;						//获取8..8之间的任意字符
	var str = 'This is 8baidu8';
	str.match(pattern);							//需要运行下，下面的语句才有作用
	//alert(RegExp.$1);							//得到第一个分组里的字符串内容
	
	var pattern = /(.*)\s(.*)/;
	var str = 'google baidu';
	var result = str.replace(pattern, '$2 $1');			//将两个分组的值替换输出
	//alert(result);
	
	/*关于贪婪和惰性*/
	var pattern = /[a-z]+/;  					//这里使用了贪婪模式
	var str = 'adsdasd';
	//alert(str.replace(pattern,'1'));			//所有的字符串都变成了1；
	
	var pattern = /[a-z]+?/;  					//这里使用了惰性模式
	var str = 'adsdasd';
	//alert(str.replace(pattern,'1'));			//只有第一个字符串都变成了1；	
	
	var pattern = /[a-z]+?/g;  					//开启全局，并且使用惰性模式
	var str = 'adsdasd';
	//alert(str.replace(pattern,'1'));			//每一个字符串都变成了1；
	
	var pattern = /8(.*)8/;						//使用了贪婪
	var str = '8google8	8google8 8google8';		//匹配到了google8	8google8 8google
	//alert(str.replace(pattern,'$1'))
	
	var pattern = /8(.*?)8/g;						//使用了惰性 开启全局
	var str = '8google8	8google8 8google8';		//匹配到了google google google
	//alert(str.replace(pattern,'$1'))
	
	
	/*使用exec返回数组*/
	var pattern = /^[a-z]+\s[0-9]{4}$/;
	var str = 'google 2014';
	//alert(pattern.exec(str));    //返回一个包含字符串的数组；
	
	var pattern = /^[a-z]+/;
	var str = 'google 2014';
	//alert(pattern.exec(str));    //只返回一个包含google的数组；
	
	var pattern = /^([a-z]+)\s([0-9]{4})$/;   //使用了分组
	var str = 'google 2014';
	var a = pattern.exec(str)
	//alert(a);    //返回一个包含字符串的数组；
	//alert(a[0]);   //返回匹配到的整个字符串	
	//alert(a[1]);   //返回匹配到的第一个分组的字符串
	//alert(a[2]);   //返回匹配到的第二个分组的字符串
	
	
	/*捕获性分组和非捕获性分组*/
	var pattern = /(\d+)([a-z]+)/;  //这个叫捕获性分组，所有的分组都捕获返回
	var str = '123abc';
	var a = pattern.exec(str)
	//alert(a);    
	//alert(a[0]);   //返回匹配到的整个字符串	
	//alert(a[1]);   //返回匹配到的第一个分组的字符串
	//alert(a[2]);   //返回匹配到的第二个分组的字符串
	
	var pattern = /(\d+)(?:[a-z]+)/;  //非捕获性分组，只要在不需要捕获返回的分组上加?:
	var str = '123abc';
	//alert(pattern.exec(str))
	
	
	/*使用前瞻捕获*/
	var pattern = /goo(?=gle)/; //goo后面必须是gle才能返回goo，这里一定要注意，返回的是goo不是google；
	var str = 'goobbb';
	//alert(pattern.exec(str))
	
	
	/*使用特殊字符匹配*/
	var pattern = /\.\[\/b\]/;						//特殊字符，用\符号转义即可
	var str = '.[/b]';
	//alert(pattern.test(str));
	
	
	/*使用换行模式*/
	var pattern = /^\d+/mg;						//首行开始匹配 并且启用了换行模式
	var str = '1.baidu\n2.google\n3.bing';
	var result = str.replace(pattern, '#');
	//alert(result);
	
	
	/*---------------------------------------分割线------------------------------------------------*/
	//五．常用的正则
	
	//1.检查邮政编码
	var pattern = /^[1-9][0-9]{5}$/;					//共6位数字，第一位不能为0
	var str = '224000';
	//alert(pattern.test(str));
	
	//2.检查文件压缩包
	var pattern = /^[\w]+\.zip|rar|gz/;	//\w表示所有数字和字母加下划线 加^表示一定要从头开始匹配
	var str = '123.zip';				//\.表示匹配.，后面是一个选择
	//alert(pattern.test(str));
	
	//3.删除多余空格
	var pattern = /\s/g;							//g必须全局，才能全部匹配
	var str = '111 222 333';
	var result = str.replace(pattern,'');				//把空格匹配成无空格
	//alert(result);
	
	//4.删除首尾空格
	var pattern = /^\s+/;
	var str = '     goo    gle          ';
	var result = str.replace(pattern,'');
	pattern = /\s+$/;
	result = result.replace(pattern,'');
	//alert('|'+result+'|');
	
	var pattern = /^\s+(.+?)\s+$/;  //(.+)是贪婪模式会继续往后匹配， 所以要开启惰性模式(.+?);
	var str = '     goo    gle          ';
	//var result = pattern.exec(str)[1];
	var result = str.replace(pattern,'$1'); //使用分组模式获取
	//alert('|'+result+'|');
	
	//5.简单的电子邮件验证
	var pattern = /^([\w\.\-]+)@([\w\-]+)\.([a-zA-Z]{2,4})$/
	var str = 'colin851@qq.com';
	//alert(pattern.test(str))
	
	
	
	
	

	</script>
	</body>
</html>
